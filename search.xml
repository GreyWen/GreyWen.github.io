<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年7月20日计划]]></title>
    <url>%2F2019%2F07%2F20%2F2019%E5%B9%B47%E6%9C%8820%E6%97%A5%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[计划 数学&quot;挑战压轴题 轻松入门篇&quot;专题13. 英语字帖第6页. 语文背诵篇目1. 新概念高中物理第二册第一章. “拓词”. 完成情况]]></content>
  </entry>
  <entry>
    <title><![CDATA[高三开学前的计划概览]]></title>
    <url>%2F2019%2F07%2F20%2F%E9%AB%98%E4%B8%89%E5%BC%80%E5%AD%A6%E5%89%8D%E7%9A%84%E8%AE%A1%E5%88%92%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[离高三开学(8月5日)还有两个星期. 高三的前三次全年级范围的考试(高三入门考试,第一次月考,第二次月考)的整体排名非常重要,学校的自主招生推荐和校内老师一对一辅导资格都会以此为依据. 因此,必须为高三开学前的两周制定详尽,实际的计划,以求恢复甚至突破停课前的文化课水平,争取在上述三次考试中进入年级前十. 总目标 数学&quot;挑战压轴题 轻松入门篇&quot;专题8到专题20的所有例题和习题. 英语字帖第6到17页. 语文高中课标必备篇目1到14. 语文小题练透第1到12练. 新概念高中物理读本第二册全部,第一册尽量多. 化学&quot;知识清单&quot;必修部分全部,有机部分尽量多. 生物必修部分全部. 复习高中英语语法和词汇.&quot;拓词&quot;每天20个新单词. 计划制定的一般原则 每天晚上睡觉前总结前一天计划的执行情况,并按照以下原则制定第二天的计划. 除语文外,通读不熟悉的教材,重新理解每一本教材的主线和发展脉络.做完教材上的例题和习题.这时不必着眼于细节和具体解题的technique. 立刻开始背语文基础知识和要求背诵的篇目.背英语单词,先教材,后TOEFL. 练字. 每本教材做完第1步后,找一些习题集和教辅,关注易错的细节和解题方法.做经典的简单和中等难度题. 写博客或手写笔记,记录心得. 作息要规律,6:30起床,23:00睡觉. 不必精确地事前计划一天中的每一个小时,要预留足够的弹性时间.但是应该精确地事后记录每一个小时的活动,以供日后改进.]]></content>
      <categories>
        <category>文化课</category>
        <category>计划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始学文化课]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%96%87%E5%8C%96%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[NOI2019 Cu,从今天开始学文化课. 这个博客以后就是文化课学习的博客. 数学,物理的公式排版应该没有问题. 要探索一下化学方程式怎么排版. 可能以后会加载很多图片,不知道Github Pages能不能承受. 化学方程式测试 4NH3+5O2⇌Δ4NO+6H2O4NH_{3}+5O_{2} \xrightleftharpoons{\Delta}4NO+6H_{2}O 4NH3​+5O2​Δ​4NO+6H2​O]]></content>
      <categories>
        <category>文化课</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019.07.06模拟赛]]></title>
    <url>%2F2019%2F07%2F06%2F2019-07-06%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[T1 DP处理出A,B,C拼成某个时刻的最小代价.枚举所有的(a,b,(a+b)(a,b,(a+b)%1440)(a,b,(a+b). T2 转化一下题意:一个左右部各有n个点的图,两部分内部共连了n-1条边,现在要在两部间连n条边,形成完备匹配,且使最终得到的图是一棵树. 先处理出左右部的连通块,考虑枚举每一个左部块,用它将某些右部块连通的过程.我们只关心每个右部块内还有多少点可以被连边,故可以将状态表示为(左部的块考虑到第几个,右部每个块的可连边的点有几个),即一个(int, multiset&lt;int&gt;). 转移时考虑一下系数即可. T3 转化题意:一个n∗nn*nn∗n的网格中,每条往右下的路径,起点,终点对其权值有贡献,每往左或下走也有贡献.求所有路径的权值和.]]></content>
      <categories>
        <category>中山纪念中学</category>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[卡常]]></title>
    <url>%2F2019%2F06%2F29%2F%E5%8D%A1%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[###寻址优化 普通写法 12for(int i = 0; i &lt; n; ++i) dp[a][b][c][d][e]....; 优秀写法 123int *f = dp[a][b][c][d][e];for (int i = 0; i &lt; n; ++i) *f....; ###取模优化 ###减少不必要的运算 123456789inline void add_fc(int *f, int val) &#123; rg int t = 0; for (rg int i = 0; i &lt; m; ++i) &#123; //f[i] = 1ll*f[i]*omega[1ll*i*val%m]%mod; //1300ms f[i] = 1ll*f[i]*omega[t]%mod; t += val; if (t &gt;= m) t -= m; &#125;&#125;]]></content>
      <categories>
        <category>知识点</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jzoj6226 纳什均衡]]></title>
    <url>%2F2019%2F06%2F27%2Fjzoj6226-%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[枚举k2k^{2}k2种重链最后指向的叶子的(c0,d0)(c_{0},d_{0})(c0​,d0​). 设dp[x][0/1][0/1][0/1]dp[x][0/1][0/1][0/1]dp[x][0/1][0/1][0/1]为四元组(A在子树x里的决策,B在子树x里的决策,子树x里权值c的分布,子树x里权值d的分布)的数量,满足: A独自改变策略能/否使自己的得分超过c0c_{0}c0​. B独自改变策略能/否使自己的得分超过d0d_{0}d0​. 按现有的决策从xxx出发,最终到达的叶子权值是否为(c0,d0)(c_{0},d_{0})(c0​,d0​). 这样做k2k^{2}k2次树形DP,每次的dp[root][0][0][1]dp[\text{root}][0][0][1]dp[root][0][0][1]就统计了结果为(c0,d0)(c_{0},d_{0})(c0​,d0​)的纳什均衡点(视作一个四元组)的个数. 因为我们枚举了所有可能的结果,且结果不同的纳什均衡点必不相同,所以这样的统计是不重不漏的.]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[min25筛]]></title>
    <url>%2F2019%2F06%2F20%2Fmin25%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[下面默认ppp是一个质数. min25筛 如果一个数论函数fff满足: fff是积性函数 f(p)f(p)f(p)是关于ppp的简单多项式 f(pk)f(p^{k})f(pk)可以快速地求出 则min25筛可以以低于线性的时间算出fff的前缀和. 如果能够O(1)O(1)O(1)求f(pk)f(p^{k})f(pk),则min25筛的时间复杂度可以认为是O(n0.75log⁡n)O(\frac{n^{0.75}}{\log n})O(lognn0.75​). 第一步:求前⌊ni⌋\lfloor\frac{n}{i}\rfloor⌊in​⌋项的质数位置的前缀和 设 g(x)=∑1≤i≤x[i∈P]f(i)g(x)=\sum_{1\leq i\leq x}[i\in P]f(i) g(x)=1≤i≤x∑​[i∈P]f(i) . 我们知道n1,n2,⋯ ,ni,⋯ ,nn\frac{n}{1},\frac{n}{2},\cdots,\frac{n}{i},\cdots,\frac{n}{n}1n​,2n​,⋯,in​,⋯,nn​只有O(n)O(\sqrt{n})O(n​)种取值.我们想要算出ggg在这每种取值处的值. 第二步:求前nnn项的最小质因子大于PjP_{j}Pj​的位置的前缀和]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Burnside引理与Polya原理]]></title>
    <url>%2F2019%2F06%2F20%2FBurnside%E5%BC%95%E7%90%86%E4%B8%8EPolya%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[陪集 拉格朗日定理 若S′S^{\prime}S′是SSS的子群,则∣G∣∣G′∣=∣{gG′:g∈G}∣\frac{|G|}{|G^{\prime}|}=|\{ gG^{\prime}:g\in G\}|∣G′∣∣G∣​=∣{gG′:g∈G}∣,即原群的大小等于子群大小乘以其陪集数. 欧拉定理作为拉格朗日定理的简单推论 显然mmm的简化剩余系ZmZ_{m}Zm​与模mmm意义下的整数乘法构成一个群(Zm,×m)(Z_{m},\times_{m})(Zm​,×m​). aaa的所有幂次构成一个子群GaG_{a}Ga​.显然a∣Ga∣=1a^{|G_{a}|}=1a∣Ga​∣=1.又因为∣Zm∣|Z_m|∣Zm​∣是∣Ga∣|G_{a}|∣Ga​∣的倍数,所以a∣Zm∣=1a^{|Z_{m}|}=1a∣Zm​∣=1,即aφ(m)=1a^{\varphi(m)}=1aφ(m)=1. 事实上,∣Ga∣|G_a|∣Ga​∣就是aaa的指标. 轨道-稳定化子定理 ∣orbit(x)∣⋅∣stab(x)∣=∣G∣|\text{orbit}(x)|\cdot|stab(x)|=|G|∣orbit(x)∣⋅∣stab(x)∣=∣G∣,即XXX里任意元素的轨道大小乘以稳定化子(xxx-不动置换)的数目等于置换群的大小. Burnside引理 轨道数=∑轨道A1=∑轨道A∑x∈A1∣A∣=∑x1∣orbit(x)∣=∑x∣stab(x)∣∣G∣=∑g∈G∣{x:g(x)=x}∣∣G∣\text{轨道数}=\sum_{\text{轨道A}}1=\sum_{\text{轨道A}}\sum_{x\in A}\frac{1}{|A|}\\ =\sum_{x}\frac{1}{|\text{orbit}(x)|}=\frac{\sum_{x}|\text{stab}(x)|}{|G|}=\frac{\sum_{g\in G}|\{x:g(x)=x\}| }{|G|} 轨道数=轨道A∑​1=轨道A∑​x∈A∑​∣A∣1​=x∑​∣orbit(x)∣1​=∣G∣∑x​∣stab(x)∣​=∣G∣∑g∈G​∣{x:g(x)=x}∣​ 即等价类的个数等于所有置换的平均不动点数. Polya计数原理 考虑若干物品的染色问题.若将物品集合记做MMM,可选颜色集合记做YYY,则 YM={f∣f:M→Y}Y^{M}=\{f|f:M\rightarrow Y\} YM={f∣f:M→Y} 即所有MMM到YYY的函数,就是所有染色方案的集合. 对于任意一个MMM上的置换ggg,容易验证与其关联的g′g^{\prime}g′: [g′(f)](x)=f(g(x)),∀f∈YM,x∈X[g^{\prime}(f)](x)=f(g(x)),\forall f\in Y^{M},x\in X [g′(f)](x)=f(g(x)),∀f∈YM,x∈X 是一个YMY^{M}YM上的置换. 所有GGG中的置换都对应一个新置换,所有的新置换仍构成一个群,记为HHH. 在不引起歧义时,可以将g′,Hg^\prime,Hg′,H仍写为g,Gg,Gg,G. 于是我们仍可以用Burnside引理得到YMY^MYM在GGG的作用下的轨道数,即平常所说的&quot;本质不同的染色方案数&quot;. 现在考虑某置换ggg在YMY^MYM上的不动点数.f∈YMf\in Y^Mf∈YM在ggg的作用下不动的充要条件是,fff在(MMM上ggg的同一轮换处)的取值相同. 如果染色方案有限制,即要统计方案全集YMY^MYM的一个子集ZZZ,且任意g∈Gg\in Gg∈G仍然是ZZZ上的置换(即满足限制的方案被作用后一定满足限制,反之亦然),那么我们还是可以使用Burnside引理,不过可能要使用其他方法(如动态规划)统计g∈Gg\in Gg∈G在ZZZ上的不动点数量(即在特定置换下不变的染色方案数)的平均值. 特殊的置换:环的旋转和翻转 例题 https://blog.csdn.net/Coldfresh/article/details/77896437]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
        <category>组合计数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合幂级数]]></title>
    <url>%2F2019%2F06%2F17%2F%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[三类常见的位运算or, and, xor分别对应三种位运算卷积,即or卷积, and卷积, xor卷积. 如果将二进制数看做集合,上面三种位运算分别对应集合的并,交,对称差.另外,我们还关心集合的不相交并. 由此我们引入下面四种位运算卷积的快速算法. 对于复数上的普通的卷积cn=∑i+j=naibjc_n=\sum_{i+j=n}a_{i}b_{j}cn​=∑i+j=n​ai​bj​,快速算法是先DFT,之后点乘,再IDFT. 事实上,下面四种位运算的前三种都有与DFT作用类似的变换与之对应.而第四种运算,即子集卷积,可以转化为前三种中的任意一种. or卷积 and卷积 xor卷积 子集卷积(不相交并)]]></content>
      <categories>
        <category>知识点</category>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019.06.13模拟赛]]></title>
    <url>%2F2019%2F06%2F15%2F2019-06-13%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[String 先考虑给定S,TS,TS,T怎样求SSS的最小代价.这等价于将SSS划分为若干连续的段,每一段都是TTT的子串,求最小划分段数. 这个问题可以贪心:将SSS的尽量长的前缀划分为一段.贪心的正确性可以用决策包容性证明. 回到原来的问题.注意到一个串是TTT的子串和它在TTT的SAM上是等价的.考虑逐个确定SSS的每一位的过程,每加入一个字符,就在TTT的SAM上做相应的转移,若无法转移则回到根节点并转移,且将代价+1+1+1.于是,我们只需预处理出从TTT上对应字符a,b,c,da,b,c,da,b,c,d的4个点中的某个点出发,以a,b,c,da,b,c,da,b,c,d中的某种转移失败结束,所需要的最小长度.这是一个4×44\times 44×4的矩阵.得到矩阵之后,只需要矩阵快速幂即可.]]></content>
      <categories>
        <category>模拟赛</category>
        <category>中山纪念中学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019.06.14模拟赛]]></title>
    <url>%2F2019%2F06%2F14%2F2019-06-14%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[game 将一个(a,b,a)(a,b,a)(a,b,a)拆分成(a),(a,b)(a),(a,b)(a),(a,b),就消去了原题的依赖关系. 于是新的问题是物品的体积为1或2的01背包. 考虑将这两种体积的物品分别从大到小排序,记为A[1..n],B[1..n]A[1..n],B[1..n]A[1..n],B[1..n]. 显然f(1)=A[1]f(1)=A[1]f(1)=A[1],现在依次确定f(2),⋯ ,f(k)f(2),\cdots,f(k)f(2),⋯,f(k). 最优决策一定选了A,BA,BA,B各自的一段前缀.进一步地,f(k+1)f(k+1)f(k+1)的决策一定是在f(k)f(k)f(k)的基础上, 多选一个体积为1的物品,或者 少选一个体积为1的物品,再多选一个体积为2的物品. 这是可以O(1)O(1)O(1)转移的. 事实上,一类类似的问题被称作&quot;可撤销的贪心&quot;.在本题中,每次转移至多撤销一次. sequence 有O(qn)O(qn)O(qn)的朴素dp.注意到每次询问都是转移询问长度次,考虑将转移用矩阵乘法表示,则每次询问就是求矩阵的区间积.复杂度是O((n+q)∣Σ∣3)O((n+q)|\Sigma|^{3})O((n+q)∣Σ∣3) 矩阵乘法还可以优化. area 点的区间和形成(n2)(n^{2})(n2)个新点,则要求的式子可以表示为截距的形式.求新点的凸包,每次在凸包上二分询问的斜率. 注意做各种操作的前后要判重,判三点共线.特别地,在做凸包之前要保证没有重合点,最好是一开始先做一次先x后y的坐标排序并unique.如果不想做额外的排序,想利用极角排序的结果,则要注意极角相同时按先x后y排序,且最左下的原点自身同样需要判重.]]></content>
      <categories>
        <category>模拟赛</category>
        <category>中山纪念中学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[错误总结]]></title>
    <url>%2F2019%2F06%2F13%2F%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[错误 1ll&lt;&lt;60而不是1&lt;&lt;60(字面量也会int溢出) 数组越界在开O2优化时会导致一些奇怪的现象,如printf没有输出. 做递归/分治的时候用到的全局变量/数组可能在递归调用中被改变. 以下的代码可能可以通过编译: 1234567int main()&#123; int A[0]; int N = 10; for (int i = 0; i &lt; N; ++i) A[i] = i * i + 3;&#125; 然而在访问A[1],A[2],...时会Segmentation fault. 注意MLE. 强制在线时,每次回答完询问要更新lastans. 两个long long相乘,对一个int取模时,要先各自取模,相乘后再取模. 形参是int时,即使传入一个long long的实参,也会先被转为int. 多测要清空. 动态开点的数据结构要算好总点数,必要时进行垃圾回收. 心得 写每个程序片段时一定要明确它的作用和适用范围(例如&quot;合并两个凸包,需要保证传入的每个凸包内两点不重合,三点不共线&quot;),写完代码一定要在头脑中梳理一遍程序的流程. 用namespace使得针对不同Subtask的程序片段间互不影响. 打表找规律. 对一个迭代的过程,一定要想清楚它的invariant是什么. 分Subtask大力讨论的题性价比高,因为写错一部分几乎不影响另一部分. You must know exactly what each piece of code is doing, even if you do not understand why they are correct. 变量名应该易于区分且简洁明了. 当不同部分的变量重名时,可以使用namespace替代把一组变量名加上前缀或后缀的做法. Think canonically. 提交答案题一定要看完所有的数据点,观察特殊性质,可以手玩小规模数据. 卡常经验 乘法较慢,除法非常慢.位运算很快. bitset很快,有时候需要手动封装一个bitset,以避免性能退化. 高频率地执行关于某个变量的简单表达式时,register可能有很好的效果. 结构体比数组慢.]]></content>
      <categories>
        <category>general</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[套路总结]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不全是套路,也有一些思想和方法. 序列分割 →\rightarrow→O(N2)O(N^{2})O(N2)DP+优化,即考虑上一个分割出的区间的结束位置. “DP套贪心” 内层的决策具有贪心性质,或是推导出最优的方案一定具有怎样的性质(如一定优先选较小的等),再以此DP. 二进制分组. 要枚举所有的(x,y),x≠y(x, y),x\neq y(x,y),x​=y时,如果不容易去掉x≠yx\neq yx​=y 的限制,可以考虑枚举x,yx,yx,y的哪一个二进制位不同.注意这样同一个pair可能被枚举多次. 树上路径第k小 考虑主席树做序列上区间第k小的过程,只需要类似地维护每个点到根的路径对应的权值线段树,利用树上差分,由四个到根路径的权值线段树可以做差得到一个两点间路径的权值线段树.每次四个点一起跳,二分找第k小即可. ∑\sum∑与∏\prod∏的转化 注意到 ln⁡(∏ai)=∑(ln⁡ai)\ln(\prod a_{i})=\sum(\ln a_{i}) ln(∏ai​)=∑(lnai​) . 因此可以取指数和对数来在和与积直接转化. 如变元矩阵树定理适用于边权积,分数规划适用于边权和. 基于xor的随机化方法 利用xor同一个值两次相当于没有做的性质. 绝对值转max⁡\maxmax ∣a∣=max⁡{a,−a}|a|=\max\{a,-a\}∣a∣=max{a,−a} 下标和值的转化 交换dp方程中的下标和值,有时可以优化状态数或者转移,例如使决策具有单调性. 答案长什么样? 哪一类特殊的解已经可以覆盖所有情况?]]></content>
      <categories>
        <category>general</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[析合树与连续段]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%9E%90%E5%90%88%E6%A0%91%E4%B8%8E%E8%BF%9E%E7%BB%AD%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[连续段 本原连续段 定义 子序列 子序列的值 对于nnn阶排列p1,p2,⋯ ,pnp_{1},p_{2},\cdots,p_{n}p1​,p2​,⋯,pn​,一个子序列xxx是一段连续的下标{lx,lx+1,⋯ ,rx}\{l_{x},l_{x}+1,\cdots,r_{x}\}{lx​,lx​+1,⋯,rx​},子序列的值val(x):={pi:i∈[lx,rx]}val(x):=\{p_i:i\in[l_{x},r_{x}]\}val(x):={pi​:i∈[lx​,rx​]}. 定义 连续段 如果子序列xxx的值也是连续的一段,即rx−lx+1=max⁡val(x)−min⁡val(x)+1r_{x}-l_{x}+1=\max val(x)-\min val(x)+1rx​−lx​+1=maxval(x)−minval(x)+1,则称xxx为连续段. 另一种等价定义是,子序列xxx是连续段当且仅当它的值中有∣x∣−1|x|-1∣x∣−1个恰好相差1的无序二元组{b,b+1}\{b,b+1\}{b,b+1}. 利用连续段的第二定义可以方便的将极长连续段问题转化为区间加法和区间最值问题,可以用可持久化线段树维护. 引理1 容易证明,如果两个连续段x,yx,yx,y部分相交(即相交但不包含),则x∩y,x∪y,x\x∩y,y\x∩yx\cap y,x\cup y,x\backslash x\cap y,y\backslash x\cap yx∩y,x∪y,x\x∩y,y\x∩y也都是连续段. 定义 本原连续段 非本原连续段 如果某个连续段xxx满足,不存在连续段yyy与xxx部分相交,则称xxx是本原连续段;否则称xxx是非本原连续段. 引理2 每个非本原连续段xxx一定能表示为若干个本原连续段的并. 证明: 长度为1的连续段显然都是本原连续段. 设xxx是非本原连续段,则∣x∣&gt;1|x|&gt;1∣x∣&gt;1.设yyy是某个与xxx部分相交的连续段.则x1=x∩y,x2=x\x∩yx_{1}=x\cap y,x_{2}=x\backslash x\cap yx1​=x∩y,x2​=x\x∩y都是连续段,且0&lt;∣x1∣,∣x2∣&lt;∣x∣0&lt;|x_{1}|,|x_{2}|&lt;|x|0&lt;∣x1​∣,∣x2​∣&lt;∣x∣.根据归纳假设,x1,x2x_{1},x_{2}x1​,x2​都可以被表示为若干(一个或多个)本原连续段的并,于是只需将x1,x2x_{1},x_{2}x1​,x2​的表示合并,就得到了xxx的表示. 析合树 定义 析合树 设全体本原连续段构成的集合为MMM,则MMM中的任意两个元素要么不相交,要么包含. MMM配备了子集偏序关系⊆\subseteq⊆后形成偏序集.这个偏序集与一个有根树TTT一一对应,满足树上节点一一对应MMM中元素,树上的祖先后代关系一一对应子集偏序关系. 如果将TTT的每个节点的儿子按照对应的连续段的下标的自然顺序排序,得到的有根有序树就称作排列ppp对应的析合树. 定义 儿子排列 对于析合树上的一个非叶节点xxx,设它有mmm个儿子,将其儿子按照值域顺序重新赋[1,m][1,m][1,m]的值,得到一个mmm阶排列q1,q2,⋯ ,qm,q_{1}, q_{2},\cdots,q_{m},q1​,q2​,⋯,qm​,称为xxx的儿子排列. 引理3 析合性质 析合树上的每个非叶节点xxx,一定满足以下两个性质中的恰好一个: 儿子排列的非平凡子序列都是连续的. 儿子排列的非平凡子序列都不是连续的. 证明: 设儿子排列有某个非平凡连续段hhh. 注意到hhh一定是非本原的(因为若不然,一定可以将hhh覆盖的儿子合并为一个新的本原连续段,作为xxx的新儿子),因此存在与hhh部分相交的h′h^{\prime}h′.令h←h∪h′h\leftarrow h\cup h^{\prime}h←h∪h′,则∣h∣|h|∣h∣一定增大了,如此迭代下去,就找到了一组非平凡非本原连续段,它们的并是整个排列. 现在我们证明,对于任意一个非平凡连续段hhh,hhh覆盖的所有位置都是某个非平凡连续段的左端点和某个非平凡连续段的右端点. … 于是,将以1,2,⋯ ,i1,2,\cdots,i1,2,⋯,i结尾的非平凡连续段依次取并,可以证明所有的前缀都是连续段;同理所有的后缀都是连续段.将前缀和后缀两两取交,就证明了所有的非平凡段都是连续的. 析合树的构造 如果给定一个析点或合点代表的区间,能求出它的儿子代表的区间,我们就可以递归地进行这个过程,构造出析合树. 另一个问题是判断一个点是析点还是合点. 模板 这是CERC2017 &quot;Intrinsic Interval&quot;一题的AC代码.此代码不是原创,在转载时添加了一些自己的注释. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include &lt;bits/stdc++.h&gt;#define pct puts("------ visit ------");#define rep(a, b, c) for(int a = (b); a &lt;= (c); ++ a)#define per(a, b, c) for(int a = (b); a &gt;= (c); -- a)using namespace std;template &lt;class T&gt; void rd(T &amp;x)&#123; x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') f = -1; ch = getchar(); &#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); x *= f;&#125;typedef pair &lt;int, int&gt; pii;const int inf = 0x3f3f3f3f;const int maxn = 1e5 + 5;int a[maxn], b[maxn];int n, m;struct persistent_segment_tree&#123; struct node&#123; int ls, rs; int ad, mi; &#125;tr[maxn * 70]; int rt[maxn], idx;#define ls tr[u].ls#define rs tr[u].rs#define lson ls, l, mid#define rson rs, mid + 1, r void newnode(int &amp;u)&#123; tr[++ idx] = tr[u]; u = idx; &#125; void addv(int u, int v)&#123; tr[u].ad += v; tr[u].mi += v; &#125; void pushdown(int u)&#123; if(tr[u].ad)&#123; newnode(ls); newnode(rs); addv(ls, tr[u].ad); addv(rs, tr[u].ad); tr[u].ad = 0; &#125; &#125; void pushup(int u)&#123; tr[u].mi = min(tr[ls].mi, tr[rs].mi); &#125; void build(int &amp;u, int l, int r)&#123; u = ++ idx; if(l == r) return (void) (tr[u].mi = 1); int mid = l + r &gt;&gt; 1; build(lson), build(rson); pushup(u); &#125; void update(int &amp;u, int l, int r, int ql, int qr, int v)&#123; newnode(u); if(ql &lt;= l &amp;&amp; r &lt;= qr) return (void) (addv(u, v)); int mid = l + r &gt;&gt; 1; pushdown(u); if(ql &lt;= mid) update(lson, ql, qr, v); if(qr &gt; mid) update(rson, ql, qr, v); pushup(u); &#125; //val &gt;= 1 at all times int query(int u, int l, int r, int ql, int qr)&#123;//leftmost pos with val == 1 if(ql &lt;= l &amp;&amp; r &lt;= qr)&#123; if(tr[u].mi == 1)&#123; int mid = l + r &gt;&gt; 1; pushdown(u); if(l == r) return l; else if(tr[ls].mi == 1) return query(lson, ql, qr); else return query(rson, ql, qr); &#125; else return -1; &#125; int mid = l + r &gt;&gt; 1; pushdown(u); if(ql &lt;= mid)&#123; int res = query(lson, ql, qr); if(res != -1) return res; &#125; if(qr &gt; mid) return query(rson, ql, qr); &#125; void build()&#123; build(rt[1], 1, n); rep(i, 1, n) b[a[i]] = i; rep(i, 2, n)&#123; rt[i] = rt[i - 1]; update(rt[i], 1, n, 1, i - 1, 1); if(a[i] &gt; 1 &amp;&amp; b[a[i] - 1] &lt; i) update(rt[i], 1, n, 1, b[a[i] - 1], -1); if(a[i] &lt; n &amp;&amp; b[a[i] + 1] &lt; i) update(rt[i], 1, n, 1, b[a[i] + 1], -1); &#125; &#125;&#125;pr, sf;//prefix, suffix#define rev(x) n + 1 - (x)const int maxs = maxn * 2;struct postive_differ_tree&#123; int pos[maxs], op[maxs]; int pre[maxs][21], dep[maxs]; pii bound[maxs]; int idx, rt; vector &lt;int&gt; e[maxs]; void adde(int u, int v)&#123; e[u].push_back(v); &#125; void divide(int &amp;u, int l, int r)&#123; u = ++ idx; bound[u] = pii(l, r); if(l == r)&#123; pos[l] = u; return ; &#125; //query(pr.rt[cur], 1, n, ql, qr) leftmost pos in [ql, qr] s.t. [pos, cur] is continuous int x = pr.query(pr.rt[r], 1, n, l + 1, r); int y = rev(sf.query(sf.rt[rev(l)], 1, n, rev(r - 1), rev(l))); int lst = l; if(y &lt; x - 1)&#123;//cannot cover the whole interval [l, r] op[u] = 0; int v; while(y != x - 1)&#123; divide(v, lst, y), adde(u, v); lst = y + 1; y = rev(sf.query(sf.rt[rev(lst)], 1, n, rev(r - 1), rev(lst))); &#125; divide(v, lst, y); adde(u, v); divide(v, y + 1, r); adde(u, v); &#125; else&#123; op[u] = 1; int v; while(y != x - 1)&#123; divide(v, lst, x - 1); adde(u, v); lst = x; x = pr.query(pr.rt[r], 1, n, x + 1, r); &#125; divide(v, lst, x - 1); adde(u, v); divide(v, x, r); adde(u, v); &#125; &#125; void dfs(int u)&#123; for(int i = 0; i &lt; e[u].size(); ++ i)&#123; int v = e[u][i]; dep[v] = dep[u] + 1; pre[v][0] = u; rep(j, 1, 20) pre[v][j] = pre[pre[v][j - 1]][j - 1]; dfs(v); &#125; &#125; int lca(int a, int b)&#123; if(dep[a] &gt; dep[b]) swap(a, b); per(i, 20, 0) if(dep[a] &lt;= dep[b] - (1 &lt;&lt; i)) b = pre[b][i]; if(a == b) return a; per(i, 20, 0) if(pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; &#125; void build()&#123; divide(rt, 1, n); dfs(1); &#125; pii query(int l, int r)&#123; if(l == r) return pii(l, r); int u = lca(pos[l], pos[r]); if(op[u] == 0) return bound[u];//xi1 pii res; int sz = e[u].size(); int ql, qr; ql = 0, qr = sz - 1; while(qr - ql &gt; 1)&#123; int mid = ql + qr &gt;&gt; 1; if(bound[e[u][mid]].first &lt;= l) ql = mid; else qr = mid; &#125; res.first = bound[e[u][ql]].first; ql = 0, qr = sz - 1; while(qr - ql &gt; 1)&#123; int mid = ql + qr &gt;&gt; 1; if(bound[e[u][mid]].second &gt;= r) qr = mid; else ql = mid; &#125; res.second = bound[e[u][qr]].second; return res; &#125;&#125;pdt;void sol()&#123; rd(m); while(m --)&#123; int l, r; rd(l), rd(r); pii res = pdt.query(l, r); printf("%d %d\n", res.first, res.second); &#125;&#125;int main()&#123; freopen("c.in", "r", stdin); freopen("c.out", "w", stdout); rd(n); rep(i, 1, n) rd(a[i]); pr.build(); reverse(a + 1, a + n + 1); sf.build(); pdt.build(); sol(); return 0;&#125;]]></content>
      <categories>
        <category>知识点</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MathJax Test]]></title>
    <url>%2F2019%2F06%2F11%2FMathJax-Test%2F</url>
    <content type="text"><![CDATA[123 P=∑i=1n(xi−x)(yi−y)[∑i=1n(xi−x)2∑i=1n(yi−y)2]1/2P = \frac {\sum_{i=1}^n (x_i- x)(y_i- y)} {\displaystyle \left[ \sum_{i=1}^n (x_i-x)^2 \sum_{i=1}^n (y_i-y)^2 \right]^{1/2} } P=[i=1∑n​(xi​−x)2i=1∑n​(yi​−y)2]1/2∑i=1n​(xi​−x)(yi​−y)​ ∑∏∫\sum \prod \int∑∏∫]]></content>
  </entry>
  <entry>
    <title><![CDATA[My New Blog]]></title>
    <url>%2F2019%2F06%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
